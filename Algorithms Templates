############ BFS 
#####Trees
from collections import deque

def bfs_tree(root):
    if not root:
        return

    queue = deque([root])  # Initialize the queue with the root node

    while queue:
        node = queue.popleft()  # Remove the front node from the queue
        print(node.val)  # Process the current node (e.g., print its value)

        # Add the children of the current node to the queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

####Graphs
from collections import deque

def bfs_graph(graph, start):
    visited = set()  # To keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the starting node
    visited.add(start)  # Mark the start node as visited

    while queue:
        node = queue.popleft()  # Remove the front node from the queue
        print(node)  # Process the current node (e.g., print its value)

        # Explore all neighbors of the current node
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append(neighbor)  # Add unvisited neighbors to the queue
                visited.add(neighbor)  # Mark the neighbor as visited

---Key Points
------Tree BFS:

-----------Straightforward as there are no cycles.
-----------Process the root, then explore its children level by level.
------Graph BFS:

-----------Use a visited set to handle cycles and avoid redundant visits.
-----------Works for both directed and undirected graphs.

##################Recursion
def recursion_function(parameters):
    # Base case: Stop recursion when a condition is met
    if base_case_condition:
        return base_case_result

    # Recursive case: Process the current state and make a recursive call
    result = process_current_state(parameters)

    # Recursive call to solve the smaller subproblem
    recursion_function(updated_parameters)

    # Optional: Combine results if necessary
    return final_result



----Base Case: Always define the stopping condition to prevent infinite recursion.
----Small Steps: Make progress in each recursive call by reducing the problem size.
----Combine Results: Aggregate results if solving multiple subproblems (e.g., divide and conquer).
----Avoid Redundant Work: Use memoization or dynamic programming to optimize recursive calls.
----Space Complexity: Recursion uses stack space proportional to the depth of the recursion tree.


def backtrack(current_state, other_parameters):
    # Base Case: If the current state is valid or a solution is found
    if is_solution(current_state):
        save_or_process_solution(current_state)
        return

    # Recursive Case: Explore all possible options
    for option in generate_options(current_state):
        if is_valid(option, current_state):  # Check if the option is valid
            apply_option(option, current_state)  # Modify the state with the option
            backtrack(current_state, other_parameters)  # Recurse with the updated state
            undo_option(option, current_state)  # Undo the change (backtracking)



N-Queens Problem
Problem:
Place n queens on an n x n chessboard such that no two queens attack each other.

Constraints:
No two queens can be in the same row, column, or diagonal.

Pruning:
Stop exploring further if placing a queen violates the above constraints.

def is_valid(board, row, col):
    # Check the column
    for i in range(row):
        if board[i] == col:
            return False

    # Check the main diagonal
    for i in range(row):
        if abs(board[i] - col) == abs(i - row):
            return False

    return True

def solve_n_queens(n):
    def backtrack(row):
        if row == n:  # Base case: All queens are placed
            result.append(["." * i + "Q" + "." * (n - i - 1) for i in board])
            return

        for col in range(n):  # Try placing queen in each column
            if is_valid(board, row, col):  # Check constraints  and  Prune invalid states
                board[row] = col  # Place the queen
                backtrack(row + 1)  # Recurse to the next row
                board[row] = -1  # Remove the queen (backtrack)

    board = [-1] * n  # Initialize the board
    result = []
    backtrack(0)
    return result

# Example Usage
n = 4
print(solve_n_queens(n))


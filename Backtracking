def backtrack(current_state, other_parameters):
    # Base Case: If the current state is valid or a solution is found
    if is_solution(current_state):
        save_or_process_solution(current_state)
        return

    # Recursive Case: Explore all possible options
    for option in generate_options(current_state):
        if is_valid(option, current_state):  # Check if the option is valid
            apply_option(option, current_state)  # Modify the state with the option
            backtrack(current_state, other_parameters)  # Recurse with the updated state
            undo_option(option, current_state)  # Undo the change (backtracking)



N-Queens Problem
Problem:
Place n queens on an n x n chessboard such that no two queens attack each other.

Constraints:
No two queens can be in the same row, column, or diagonal.

Pruning:
Stop exploring further if placing a queen violates the above constraints.

def is_valid(board, row, col):
    # Check the column
    for i in range(row):
        if board[i] == col:
            return False

    # Check the main diagonal
    for i in range(row):
        if abs(board[i] - col) == abs(i - row):
            return False

    return True

def solve_n_queens(n):
    def backtrack(row):
        if row == n:  # Base case: All queens are placed
            result.append(["." * i + "Q" + "." * (n - i - 1) for i in board])
            return

        for col in range(n):  # Try placing queen in each column
            if is_valid(board, row, col):  # Check constraints  and  Prune invalid states
                board[row] = col  # Place the queen
                backtrack(row + 1)  # Recurse to the next row
                board[row] = -1  # Remove the queen (backtrack)

    board = [-1] * n  # Initialize the board
    result = []
    backtrack(0)
    return result

# Example Usage
n = 4
print(solve_n_queens(n))

################Permuatations Problem

class Solution(object):
    # Helper function to perform recursive backtracking
    def permuteHelper(self, nums, current_result, result):
        """
        This function generates permutations by exploring all possible arrangements 
        of `nums` using recursion and backtracking.
        
        :param nums: List[int] - The list of numbers to permute.
        :param current_result: List[int] - The current partial permutation.
        :param result: List[List[int]] - The list to store all complete permutations.
        """
        
        # Base case: When the current result contains all the numbers
        if len(current_result) == len(nums):
            # Add a copy of the current permutation to the result
            result.append(current_result[:])  # Use [:] to avoid reference issues
            return
        
        # Iterate over all numbers in the input list
        for i in range(len(nums)):
            # Check if the current number is already in the partial result
            if nums[i] not in current_result:  # Avoid using the same number more than once
                # Include the current number in the partial result (Choose)
                current_result.append(nums[i])
                
                # Recursively explore with the updated partial result (Explore)
                self.permuteHelper(nums, current_result, result)
                
                # Remove the last number added to backtrack (Unchoose)
                current_result.pop()
    
    # Main function to generate permutations
    def permute(self, nums):
        """
        This function initializes the recursive process to generate permutations.
        
        :param nums: List[int] - The list of numbers to permute.
        :return: List[List[int]] - A list containing all permutations of the input list.
        """
        result = []  # Initialize the result list to store permutations
        self.permuteHelper(nums, [], result)  # Start the backtracking process
        return result  # Return the list of permutations

--------------Coin Change 

def coinChangeRecursive(coins, amount):
    def backtrack(remaining, index):
        if remaining == 0:
            return 1  # Found a valid combination
        if remaining < 0 or index == len(coins):
            return 0  # No valid combination

        # Include the current coin
        include = backtrack(remaining - coins[index], index)
        # Exclude the current coin
        exclude = backtrack(remaining, index + 1)

        return include + exclude

    return backtrack(amount, 0)
